# 비트 연산

> 비트 연산자

- &
  - 비트단위로 AND 연산을 한다.
  - 자리의 비트가 둘 다 1이면 1, 아니면 0으로 만든다.
  - 15(1111~(2)~) & 10(1010~(2)~) == 10(1010~(2)~)
- |
  - 비트 단위로 OR 연산을 한다.
  - 자리의 비트가 둘 다 0이라면 0, 아니면 1로 만든다.
  - 14(1110~(2)~) & 10(1010~(2)~) == 14(1110~(2)~)
- ^
  - 비트단위로 XOR(같으면 0 다르면 1) 연산을 한다.
  - 자리의 비트가 서로 다르다면 1, 같으면 0으로 만든다.
  - 10(1010~(2)~) ^  5(101~(2)~) == 15(1111~(2)~)
- ~
  - 단항 연산자로서 피연산자의 모든 비트를 반전시킨다.
  - 자리의 비트가 0이라면 1로, 1이라면 0으로 만든다.
  - ~ 10(1010~(2)~) == - 11(?)
- <<
  - 피연산자의 비트 열을 왼쪽으로 이동시킨다.
  - 10 << 2 == 40(101000~(2)~)
- `>>` 
  - 피연산자의 비트 열을 오른쪽으로 이동시킨다.



> 1 << n

- 2^n^의 값을 갖는다.
- 원소가 n개일 경우의 모든 부분집합의 수를 의미한다.
- Power set(모든 부분 집합)
  - 공집합과 자기 자신을 포함한 모든 부분집합
  - 각 원소가 포함되거나 포함되지 않는 2가지 경우의 수를 계산하면 모든 부분집합의 수가 계산된다
- i & (1 << j)
  - 계산 결과는 i의 j번 비트가 1인지 아닌지를 의미한다.

- 비트 연산 예제

```python
# 비트 연산 예제

# 0번 비트부터(우측부터) 7번 비트까지 출력하는 함수
def Bbit_print(i):
    output = ''
    for j in range(7, -1, -1):
        output += '1' if i & (1 << j) else '0'
    print(output, end=' ')


a = 0x10 # 십진수 16
x = 0x01020304 # 16진수 머시기
# x를 이진수로 바꾸면 1000000100000001100000100
print(bin(x))

# 16진수 한 자리(0 ~ f(15))는 이진수 4자리!
print('%d = ' % a, end='')
Bbit_print(a)
print()
print('0%x = ' % x, end='')
for i in range(0, 4):
    # 16진수 x를 2진수로 변환한 후 우측부터 8자리씩 끊어 찍음!
    # 다만 이제 8자리씩 끊어 찍다 보니 
    # 이진수로 변환한 값 앞에 0을 7개 붙인 00000001000000100000001100000100을 찍는 식으로 됨
    # 리틀 엔디안이라고 볼 수 있겠다.
    Bbit_print((x >> i * 8) & 0xff)
```



> 엔디안(Endianness)

- 컴퓨터의 메모리와 같은 1차원의 공간에 여러 개의 연속된 대상을 배열하는 방법을 의미하며 HW 아키텍처마다 다르다.
- 주의: 속도 향상을 위해 바이트 단위와 워드 단위를 변환하여 연산 할 때 바르게 이해하지 않으면 오류를 발생 시킬 수 있다.

- 엔디안은 크게 두 가지로 나뉨

  - 빅 엔디안
    - 보통 큰 단위가 앞에 나옴 => 네트워크
  - 리틀 엔디안
    - 작은 단위가 앞에 나옴. 대다수 데스크탑 컴퓨터

  |    종류     | 0x1234의 표현 | 0x12345678의 표현 |
  | :---------: | :-----------: | :---------------: |
  |  빅 엔디안  |     12 34     |    12 34 56 78    |
  | 리틀 엔디안 |     34 12     |    78 56 34 12    |

- 엔디안 확인 코드
  - `import sys`
  - `print(sys.byteorder)`