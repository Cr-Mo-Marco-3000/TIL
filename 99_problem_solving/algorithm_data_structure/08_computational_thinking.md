# Computational Thinking

## 1. 서문

- 논리적으로 정확하게 확인하는 연습
- 되는 것 같다는 기분이나 '공식을 외우는 것' 말고 정확하게 확인해 본 적이 있는가?
- 프로그램을 짜기 시작하기 전에, 정확한 결과가 나올 것인지, 얼마나 빠르게 돌아갈 것인지 미리 알 수 있는가?
- 확인이 안 된 상태에서 프로그램을 짜기 시작하면, 결과가 정확할지, 얼마나 빠를지 예측할 수 없고, 제대로 된 결과가 나오지 않으면 고치는 것이 어렵고 무작정 여러가지를 시도해 볼 수 밖에 없다
- 정확히 확인하는 훈련이 되어 있지 않으면, 단순 작업 이상의 코드를 작성하기 어렵고, 다른 사람의 코드를 고치는 것도 매우 어렵다.
- 정확하게 확인하는 과정을 수많은 세월 동안 정리해 둔 것이 '증명' 기법이다.
- 증명 기법은 딱딱한 것이 아닌 기발한 아이디어들의 집합이고 '이해하면 재미있는 그림'들과 같다.
- 이 과정에서 쉬운 문제들을 보고 정확하게 확인하는 것을 연습해 보자.



> 논리(Hard Logic)

- Hard vs Soft Logic
  - 직관은 논리적인 느낌을 주는 것
  - 직관의 장점은 (익숙한 상황에서) 빠르다는 것
  - 직관의 단점은 정확하지 않다는 것
  - 또 다른 단점은 강한 착각을 일으킨다는 것



- 일상 생활에서는 
  - Soft Logic이 빠르기 때문에 유용
  - 논리적으로 부정확한 표현을 사용하지만, 어떤 의미인지 모든 사람이 이미 알고 있다는 가정이 존재



- 프로그래밍은 Hard Logic을 사용
  - 프로그래밍 언어의 표현들이 모두 논리학에서 나온 것
  - 사용되는 수많은 알고리즘들을 이해하기 위해서는 Hard Logic이 필요



- 오해의 근원
  - Soft Logic으로 알고리즘을 이해하려고 하는 것!
  - 알고리즘 설명을 보고 또 봐도 이해가 안되는 것은 증명을 안 봤기 때문
  - 증명을 봐도 이해가 안되는 것은 직관으로 이해하려고 하기 때문
  - 가끔 직관적으로 이해되는 알고리즘이 있지만 조금만 어려워지면 직관으로 완전한 이해를 얻는 것은 사실상 불가능



> 참고

- 명제

  - 참이자 거짓을 알 수 있는 식이나 문장.
  - p, q, r로 표현

- 진리값

  - 참이나 거짓을 표현
  - T, F 또는 1, 0

  

> 연산(결합)

- 부정 NOT
  - p가 명제일 때, 명제의 진릿값이 반대
  - ~p 또는 ㄱp로 표기 (not p 또는 p의 부정으로 읽음)
- 논리곱 AND
  - p, q가 명제일 때, p, q 모두 참일 때만 참이 되는 명제
  - p ^ q (p and q, p 그리고 q)
- 논리합 OR(Inclusive OR)
  - p, q가 명제일 때, p, q 모두 거짓일 때만 거짓이 되는 명제
  - p V q(p or q, p 또는 q)
- 배타적 논리합 XOR(Exclusive OR)
  - p, q가 명제일 때 p, q 중 하나만 참일 때 참이 되는 명제
  - p xor q



> 연산자 우선 순위

- ~ > V, ^ >  => ,  <=> 
- 항진명제: 진리값이 항상 참
- 모순명제: 진리값이 항상 거짓
- 사건명제: 항진명제도 모순명제도 아닌 명제



> 조건명제

- p, q가 명제일 때, 명제 p가 조건(또는 원인), q가 결론(또는 결과)로 제시되는 명제
- p -> q (p이면 q이다.)
- 아래 정도는 외워 두자

|  p   |  q   | p -> q |
| :--: | :--: | :----: |
|  T   |  T   |   T    |
|  T   |  F   |   F    |
|  F   |  T   |   T    |
|  F   |  F   |   T    |



> 쌍방조건명제

- p, q가 명제일 때, 명제 p와 q가 모두 조건이면서 결론인 명제

- p <-> q (p면 q고, q면 p다.)

  

|  p   |  q   | p <-> q |
| :--: | :--: | :-----: |
|  T   |  T   |    T    |
|  T   |  F   |    F    |
|  F   |  T   |    F    |
|  F   |  F   |    T    |



> 조건명제의 역, 이, 대우

- 역: q -> p
- 이: ~q -> ~p
- 대우: ~q -> ~p (p -> q와 동일한 의미)

|  p   |  q   | p -> q | q -> p | ~p -> ~q | ~q -> ~p |
| :--: | :--: | :----: | :----: | :------: | :------: |
|  T   |  T   |   T    |   T    |    F     |    T     |
|  T   |  F   |   F    |   T    |    T     |    F     |
|  F   |  T   |   T    |   F    |    F     |    T     |
|  F   |  F   |   T    |   T    |    T     |    T     |



> 논리 연습

- 문제 1: 다음을 명제식 형태로 쓰고 참인지 거짓인지 판단하시오

  1. 만약 0이 홀수라면, 미국에서 2080년 월드컵이 열린다.
     - 앞이 F이므로, 결론은 T

  2. 만약 1989382792324234이 Prime Number라면, 2는 짝수이다.
     - 뒤가 T이므로, 결론은 T

  - 조건명제일 경우, 양쪽을 다 확인할 필요가 없을 수 있다.



- 문제 2: p와 q가 명제이고 p -> q가 거짓이라고 하자. 다음 명제식의 참 거짓은 어떻게 되는가?

  - p: T, q: F

  1. ~p -> q
     - F -> F : T

  2. p V q
     - T V F: T

  3. q -> p
     - F -> T: T



- 문제 3: 다음 명제들의 역, 이, 대우를 쓰시오
  1. 만약 0이 홀수라면, 미국에서 2080년 월드컵이 열린다.
  2. 만약 29301240971590873이 Prime Number라면, 2는 짝수이다.



- 문제 4: 다음 명제식의 진리표를 만드시오
  1. p ^(q->~p)
  2. (p^~q)->r

|  p   |  q   | ~ p  | q -> ~p | p  ^ (q -> ~p) |
| :--: | :--: | :--: | :-----: | :------------: |
|  T   |  T   |  F   |    F    |       F        |
|  T   |  F   |  F   |    T    |       T        |
|  F   |  T   |  T   |    T    |       F        |
|  F   |  F   |  T   |    T    |       F        |



> 증명

- 증명은 정확한 명제식으로 표현할 수 있는 것이라야 함
- 보통은 정확한 명제식까지 쓰지는 않으나 근본적으로는 명제식으로 바꿀 수 있음
- 증명에 대한 수많은 오해가 p -> q를 p <->와 혼동하는 것에서 일어남



> 증명 연습

- Trivial Proof: 모든 x에 대해, P(x) -> Q(x)를 증명하려는데, Q(x)가 항상 참인 경우
  - Q(x)가 참이면 앞과 관계 없이 p ->q 는 T
- Vacuous Proof: 모든 x에 대해, P(x) -> Q(x)를 증명하려는데, P(x)가 항상 거짓인 경우
  - P(x)가 거짓이면 뒤와 관계 없이 p -> q는 T



> 진리표를 이용해 항진명제 증명

- 우선순위를 이용해 한 단계씩 증명해 나가면 됨



> 명제식의 변형을 통한 명제 간소화

- (p ^ ~q) V (p ^ q) => p ^ (~q V q) 묶을 수 있음
  - p ^ U(항진명제) => p



## 2. 수와 표현

- 컴퓨터는 0/1을 표현할 수 있는 비트들을 모아 수를 표현
- k개의 비트를 사용하면 0부터 2^k^-1까지 표현 가능
  - 예를 들어, 비트를 3개 사용한다면
  - 000~(2)~ == 0 부터 111~(2)~ == 7 까지 표현 가능

- 사실, 꼭 저 범위인 것은 아님. 약속하는 방식에 따라 다르지만, 어떤 경우든 최대 2^k^ 가지의 값을 표현하는 것이 가능
- 10진수로 k자리를 쓰면 0부터 10^k-1까지 표현이 가능한 것과 완전히 동일한 과정
- 어떤 값 n을 표현하기 위해서는 몇 개의 비트가 필요할까?
  - 2^k^-1 >= n이 성립해야 함  => 즉, 2^k^ >= n + 1
  - 같은 의미로, k >= log(n+1) => **약 log~2~ n 비트가 필요**
  - x = log n 과  2^x^= n은 같은 말
  - 컴퓨터 분야에서 로그의 밑은 항상 2
  - 32비트 컴퓨터의 주소 공간은 2^32^ == 약 40억개 주소



## 3. 집합과 조합론

- 두 집합 A와 B에 대해 A가 B의 부분집합임을 증명한다는 것은 A의 임의의 원소가 B에 포함됨을 보이는 것과 같다.
- 예를 들어 모든 4의 배수는 2의 배수라는 것을 증명하려면, 4k = 2(2k)임을 보이면 되는 것이다.
- 두 집합 A와 B가 같다는 것을 증명하기 위해서는 각각 서로가 서로의 부분집합이라는 것을 증명하면 된다.



> 조합론

- 조합론은 경우의 수를 따지는 문제들을 보통 말한다
- 조합의 개수는 C를 이용하여 표현하기도 하지만 괄호 표현을 더 많이 쓴다.



> 귀류법

- 한 명제가 참인 것을 증명하려 할 때, 명제의 부정을 참이라고 가정하고 명제의 모순을 증명해서 원래의 명제가 참임을 보임.



## 4. 기초 수식

> 약간의 설명

- 알고리즘의 시간 복잡도를 표현할 수 있는 다양한 수식들이 존재한다.
- 풀이법을 익혀 두어야 알고리즘의 시간 복잡도를 계산할 수 있고, 알고리즘이 시간이 얼마나 걸릴 지 예측할 수 있다.
- T(n) = T(n-1) + 1, T(0) = 1

  - => k = n인 경우

  - => T(n-k) + k

  - O(n)
- T(n) = T(n-1) + log n, T(0) = 1
  - O(nlogn)



## 5. 재귀

> 약간의 설명

- 재귀란 자기 자신을 호출하는 함수, 그럼 끝날 수가 있는가?
- 함수는 입력이 있으며, 자기 자신의 입력과 동일한 입력으로 자기 자신을 호출하면 당연히 끝나지 않음
- 하지만, 다른 입력으로 호출하면 끝날 수 있음



## 6. 동적 프로그래밍

- 간단하게 설명하면 재귀 함수에서 동일한 입력의 함수 호출이 반복적으로 일어날 때 그 결과 값을 저장해 두고 불러 쓰는 것이다. (Memoization)
- 최초 입력에서 파생되는 모든 가능한 입력에 대한 답을 모두 저장할 수 있는 메모리가 있어야 한다
- 단순히 재귀에서 저장된 값을 찾아보는 것으로도 가능하지만, 결과 값을 순서를 정해서 계산할 수도 있다.(Dynamic Programming)


