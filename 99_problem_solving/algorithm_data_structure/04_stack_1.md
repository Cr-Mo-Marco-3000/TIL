# Stack 1

## 데이터와 타입



- 기존에는 데이터와 프로그램을 따로 분류
  - 데이터
    - 경험이나 관찰로부터 얻어진 조직화된 정보의 모음
    - 과거: 프로그램 코드가 아닌 모든 것

  - 프로그램
    - 명령 또는 컴퓨터가 수행할 작업


- 데이터는 컴퓨터에 어떻게 저장될까?
  - 스토리지
    - 데이터가 영구히 저장되는 곳
    
    - 용량이 작지만 속도가 매우 빠름
    
      
    
  - 메모리
    - 데이터가 임시적으로 저장되는 곳
    - 용량이 작지만 속도가 매우 빠름
    - 당장 필요한 데이터가 위치
    - 메모리를 효율적으로 이용하자!
      - 데이터가 저장 되는 위치 Random(순서가 없지만 주소가 있어서)
      - Random Access Memory
      - 각 칸마다 주소값이 지정되어 있음



- 데이터 타입(Data Type)
  - 왜 중요한가?
    - 다루는 데이터의 특성을 반영하기 위해서
    
  - 현실 세계의 데이터를 0과 1로 표현해서 메모리에 저장하기 위한 방법
    - 좋은데... 한계가 있음
    
      

- 더 다양한 데이터 구조를 표현하고 싶을 때, 사용자가 데이터 타입을 정의
  - User-defined data type
    - 클래스를 이용해서 나만의 데이터 타입을 선언
      - 학번, 학과, 이름, 성별, 나이
      
      

## 자료구조의 종류

- 자료구조란?

  - 데이터를 효율적으로 저장하고 관리하기 위한 방법

  

- 선형 자료구조
  - 자료 간의 관계가 1대 1의 관계를 갖는다
  - list, stack, queue, linked list 등



- 비선형 자료구조
  - 자료 간의 관계가 1대 N의 관계를 갖는다.
  - graph, tree 등




- 자료구조 쓰면 뭐가 좋아요?
  - 데이터의 구조를 전체적으로 파악해서 효율적으로 사용 가능
  - 데이터에 맞는 자료구조
    - 데이터를 표현하기 쉽고
    - 데이터를 이해하기 쉽고
    - 데이터를 활용하기도 쉽다!



- 추상 데이터 타입(Abstract Data Type)

  - 구조화된 데이터를 필요한 연산과 함께 묶어서 표현하는 방법

    - 개별적인 특징을 지우고
    - 데이터가 가진 공통점
      - 데이터 구조의 특징을 도출
      - 필요한 연산을 정의
  - 추상화
    - 특정한 대상이나 사람이나 상황이 아닌 일반적인 개념으로 만드는 것



## 스택



- 물건을 쌓아 올린 듯 자료를 쌓아 올린 형태의 자료 구조

  - 리스트는 스택이 아니다! => 그럴 수도 있고 아닐 수도 있다.

  

- 스택에 저장된 자료는 선형 구조를 갖는다.

- 스택에 자료를 삽입하거나 스택에서 자료를 꺼낼 수 있다.

- 특징

  - 크기 존재
  - 후입선출
  - 가장 위에서만 데이터의 삽입, 삭제가 일어난다.

- 연산: 구현해보자

  - if_full
  - if_empty
  - push
  - peek
  - pop

  

  

- 스택을 프로그램에서 구현하기 위해서 필요한 자료구조와 연산

  - 자료구조: 자료를 선형으로 저장할 저장소

    - size

    - items

    - 스택에서 마지막 삽입된 원소의 위치를 top이라 부른다.

      - 공식 명칭은 stack pointer


​      

- 연산

  - 삽입: 저장소에 자료를 저장한다. 보통 push라고 부른다.
    - top을 1 증가시킨다.
    - A를 top이 가리키는 장소에 집어넣는다.
  - 삭제: 저장소에서 자료를 꺼낸다. 꺼낸 자료는 삽입한 자료의 역순으로 꺼낸다. 보통 pop이라고 부른다.
    - top이 가리킨 애를 꺼낸다.
    - top을 감소시킨다.
      - 엄밀히 말해 꺼낸다고 지워지지는 않지만, push할 때 덮어씌워진다.
  - 스택이 공백인지 아닌지를 확인하는 연산. isEmpty
  - isfull
  - 스택의 top에 있는 item(원소) 을 반환하는 연산. peek

- 요런 구조를 가지고 요런 연산이 가능하면 => 스택이라는 자료구조

함수 내부 => 외부로 값 넘기기 return
외부 => 내부 값 넘기기 argument

함수 내부에서, 변수 자체를 참조만 하는 것이 아니라 수정하고 싶다면 global을 사용한다.

```python
# 스택의 push 알고리즘
# append 메소드를 통해 리스트의 마지막에 데이터를 삽입

def push(item):
    s.append(item)
# or

def push(item, size):
    global top
    # top을 1 증가
    top += 1
    # top이 인덱스를 벗어났을 때 넘쳤다고 알려준다.
    # stack의 크기를 작게 잡았거나, 과도한 push 회수를 하면 넘친다.
    # 이 부분은 디버깅용
    if top == size:
        print('overflow!')
    # 인덱스 안에 있다면, 그 위치에 item을 저장한다.
    else:
        stack[top] = item


size = 10
stack = [0] * size 
top = -1



push(10, size)

# 아래와 같이 직접 구현 가능
top += 1			# push(20)
stack[top] = 20		# 
    
    
    
    
# 스택의 pop 알고리즘

def pop():
    if len(s) == 0:
        #underflow
        return
    else:
        return s.pop(-1)
    
    
    
# or

def pop():
    global top
    if top == -1:
        print('underflow!')
        return 0
    else:
        top -= 1 # 리턴을 바로 하기 위해 이렇게 표현
        return stack[top+1]
    
print(pop())

# 이렇게 구현도 가능
if top > -1:
    top -= 1
    print(stack[top+1])

    

```

- 스택 구현 고려 사항
  - 1차원 배열을 사용하여 구현할 경우 구현이 용이하다는 장점이 있지만, 스택의 크기를 변경하기가 어렵다는 단점이 있다.
  - 이를 해결하기 위한 방법으로 저장소를 동적으로 할당하여 스택을 구현하는 방법이 있다. 동적 연결리스트를 이용하여 구현하는 방법을 의미한다. 구현이 복잡하다는 단점이 있지만 메모리를 효율적으로 사용한다는 장점을 가진다. 스택의 동적 구현은 생략한다.



### 스택의 응용

- 스택의 응용 1: 괄호검사
  - 괄호의 종류: 대괄호, 중괄호, 소괄호
  - 조건
    - 왼쪽 괄호의 개수와 오른쪽 괄호의 개수가 같아야 한다.
    - 같은 괄호에서 왼쪽 괄호는 오른쪽 괄호보다 먼저 나와야 한다.
    - 괄호 사이에는 포함 관계만 존재한다.
- 스택의 응용 2: Function Call
  - 프로그램에서의 함수 호출과 복귀에 따른 수행 순서를 관리
    - 가장 마지막에 호출된 함수가 가장 먼저 실행을 완료하고 복귀하는 후입선출 구조이므로, 후입선출 구조의 스택을 이용하여 수행순서 관리
    - 함수 호출이 발생함면 호출한 함수 수행에 필요한 지역변수, 매개변수 및 수행 후 복귀할 주소 등의 정보를 스택 프레임에 저장하여 시스템 스택에 삽입
    - 함수의 실행이 끝나면 시스템 스택의 top원소(스택 프레임)을 삭제(pop)하면서 프레임에 저장되어 있던 복귀주소를 확인하고 복귀
    - 함수 호출과 복귀에 따라 이 과정을 반복하여 전체 프로그램 수행이 종료되면 시스템 스택은 공백 스택이 된다.
- 재귀 호출
  - 자기 자신을 호출하여 순환 수행되는 것
  - 함수에서 실행해야 하는 작업의 특성에 따라 일반적인 호출방식보다 재귀호출방식을 사용하여 함수를 만들면 프로그램의 크기를 줄이고 간단하게 작성
  - 재귀 호출의 예) factorial
    - 마지막에 구한 하위 값을 이용하여 상위 값을 구하는 작업을 반복
  - 재귀호출도 다른 함수를 호출하는 것과 동일하게 생각하면 편하다.

```python
def facto(n):
    if n == 1:
        return 1
    else:
        return n * facto(n-1)
```

- 재귀함수는 각자 다른 메모리 영역에 값이 저장된다.



- 피보나치 수열 구현

```python
def fibo(n):
    if n < 2:
        return n
    else:
        return fibo(n-1) + fibo(n-2)
        
```



- 보통의 재귀함수

```python
f(i, N) 
# i는 현재, N은 목표: 원래 두 개의 인덱스를 갖는 게 기본형
# 위의 피보나치보다는 이 내용이 재귀의 기본형이라고 할 수 있다.


def copy(i, N):
    if i == N:
        print(b)
    else:
        b[i] = a[i]
        f(i+1, N)
        
a = [10, 20, 30]
b = [0, 0, 0]
copy(0, 3)
```

```python
def f(n):
    global cnt
    cnt += 1
    if N<2:
        return n
    else:
        return f(n-1) + f(n-2)
N = 40
cnt = 0 # 재귀호출 시 331160281번 돈다...
print(f(N))
```



- memoization
  - 앞의 예에서 피보나치 수를 구하는 함수를 재귀함수로 구현한 알고리즘은 문제점이 있다.
  - 엄청난 중복 호출이 존재한다는 것이다.
  - 피보나치 수열의 Call Tree
- 메모이제이션은 컴퓨터 프로그램을 실행할 때, ~~



```python
def fibo1(n):
    global memo
    if n >= 2 and len(memo) <= n:
        memo.append(fibo(n-1) + fibo(n-2))
    feturn memo[n]

    
    
# or

def fibo(n):
    global cnt
    cnt += 1
    if n >= 2 and memo[n] == 0:
        memo[n] = fibo(n-1) + fibo(n-2)
    return memo[n]
    
    
N = 10
memo = [0] * (N+1)
memo[0] = 0
memo[1] = 1
cnt = 0
print(fibo(N)) # 얘는 N= 40짜리 구할 때 재귀임에도 불구하고 79번 돔
print(memo)

```



- DP
  - 동적 계획(Dynamic Programming) 알고리즘은 그리디 알고리즘과 같이 최적화 문제를 해결하는 알고리즘이다.
  - 동적 계획 알고리즘은 먼저 입력 크기가 작은 부분 문제들을 모두 해결한 후에 그 해들을 이용하여 보다 큰 크기의 부분 문제들을 해결하여, 최종적으로 원래 주어진 입력의 문제를 해결하는 알고리즘이다.
- 피보나치 수 DP 적용
  - 피보나치 수는 부분 문제의 답으로부터 본 문제의 답을 얻을 수 있으므로 최적 부분 구조로 이루어져 있다.

```python
N = 10
fibo = [0] * (N+1)
fibo[0] = 0
fibo[1] = 1

for i in range(1, N+1):
    fibo[i] = fibo[i-1] + fibo[i-2]

print(fibo)
```

- memoization을 재귀적 구조(recursive 방식)에 사용하는 것보다 반복적 구조(iteratibe 방식)로 DP를 구현한 것이 성능 면에서 효율적. 단, 모든 경우에서 빠르지는 않음
- 재귀적 구조는 내부에 시스템 호출 스택을 사용하는 오버헤드가 발생하기 때문이다.

- DFS(깊이우선탐색)
  - 비선형구조인 그래프 구조는 그래프로 표현된 모든 자료를 빠짐없이 검색하는 것이 중요함
  - 두 가지 방식
    - 깊이 우선 탐색(Depth First Search, DFS)
    - 너비 우선 탐색(Breadth First Search, BFS)



- 함수 콜 스택
  - 재귀호출 했을 때, 디버거에 쌓이는 모습
  - 스택은 재귀함수를 설명하기 위해 만든 개념!

