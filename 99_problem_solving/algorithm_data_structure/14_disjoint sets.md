# 서로소 집합

> 서로소 집합(상호배타 집합) - Disjoint Sets

- 서로소 또는 상호배타 집합들은 서로 중복 포함된 원소가 없는 집합들이다. 다시 말해 교집합이 없다.
- 집합에 속한 하나의 특정 멤버를 통해 각 집합들을 구분한다. 이를 대표자(Representative)라 한다.
- 상호 배타 집합을 표현하는 방법
  - 연결 리스트
  - 트리
- 상호 배타 집합 연산
  - Make-Set(x)
  -  Find-Set(x)
  -  Union(x, y)



> 상호 배타 집합 표현 - 연결 리스트

  - 같은 집합의 원소들은 하나의 연결리스트로 관리한다.
  - 연결리스트의 맨 앞의 원소를 집합의 대표 원소로 삼는다.
  - 각 원소는 집합의 대표원소를 가리키는 링크를 갖는다
  - 자세한 구현 방법은 생략한다.



>  상호 배타 집합 표현 - 트리

- **하나의 집합**을 **하나의 트리**로 표현한다.
  - 한 마디로 정리하자면, 여러 집합이 몇 개의 트리로 구성되어 있고, 어떤 원소는 어떤 트리에 속해 있는가를 찾는 과정이다.
  - 연산은 재귀를 쓰지 말고 반복을 쓰는 게 합리적이다.



- 자식 노드가 부모 노드를 가리키며 루트 노드가 대표자가 된다.
  - 루트 노드는 부모를 자기 자신으로
- Make-Set(x): 유일한 멤버 x를 포함하는 새로운 집합을 생성하는 연산
- Find-Set(x): x를 포함하는 집합을 찾는 연산
- Union(x, y): x와 y를 포함하는 두 집합을 통합하는 연산

```python
def make_set(x):
    p[x] = x

def find_set(x):
    # 반복
    while x != p[x]:
        x = p[x]
    return x

    # 재귀
    # if x != p[x]:
    #     p[x] = find_set(p[x])
    # return p[x]


def union(x, y):
    p[find_set(y)] = find_set(x)

#1.
p = [0] * (6 + 1)
print(p)

for i in range(1, 7):
    make_set(i)

print(p)
print('----------------------------------')

#2.
union(1, 3)
print(p)
print('----------------------------------')

union(2, 3)
print(p)
print('----------------------------------')

union(5, 6)
print(p)
print('----------------------------------')

#3.
print(find_set(6))
print(find_set(3))
print(find_set(2))
```



> Kruskal 알고리즘

- 간선 중심
- 사이클(돌아오는 구조) 가 있으면 안됨, 따라서 서로소 집합을 활용(서로소 집합이 있으면 안됨)

- 간선을 하나씩 선택해서 MST를 찾는 알고리즘

1) 최초, 모든 간선을 가중치에 따라 오름차순으로 정렬
2) 가중치가 가장 낮은 간선부터 선택하면서 트리를 증가시킴
   - 사이클이 존재하면 다음에는 

