

## 진수

> 2진수, 8진수, 10진수, 16진수

> 10진수 => 차 진수로 변환

- 원하는 타진법의 수로 나눈 뒤 나머지를 거꾸로 읽는다.
- 예지) (149)~10~ = (10010101)~2~ = (225)~8~ = (95)~16~



> 타 진수 => 10진수로 변환

- 예) (135)~8~ = 1 X 8^2^ + 3 X 8 + 5 = 93



> 컴퓨터에서의 음의 정수 표현 방법

- 1의 보수: 부호와 절대값으로 표현된 값을 부호 비트를 제외한 나머지 비트들을 0은 1로, 1은 0으로 변환한다



> 보수

- 이진수 뺄셈
- 컴퓨터는 덧셈밖에 하지 못하기 때문에(가산기)
- 뺄셈에 보수를 이용한다



> 음수 표현

- MSB(Most Significant Bit)
  - 맨 앞 비트를 1이면 음수, 0이면 양수로 표현
  - 근데 컴퓨터는 이렇게 표현을 안함
  - 0000, 1000 이 같은 수인데 +0, -0이 생기기
  - 연산에서도 우리가 원하는 대로 안 됨 0001 + 1001
  - 따라서 표현만 이렇게 함
- 두 번째 방법
  - 1의 보수 => not
  - 순서
    - 양수는 이진법으로 변환
    - 음수는 절대값을 이진법으로 바꾼 후 보수처리해서 더해준다
    - 4bit를 넘어서면 carry bit라고 해서, 그 부분은 비트 안쪽에 더해준다.
  - 편리하지만, 얘도 여전히 +-0이 생기는 문제가 있다.



- 세 번째 방법(실제로 컴퓨터 내부에서 처리되는 방식)
  - 2의 보수 => 1의 보수 + 1
  - e.g. 
    - 33 = > 0100001~(2)~
    - -33 => 1011110~(2)~
    - 여기까지 1의 보수
    - 2의 보수는 1을 더해서 
    - -33 => 1011111~(2)~
    - 십진수로 변환
    - 앞 자리 1 분리
    - 이후 역순으로 1빼주면 다시 011110~(2)~
    - 이후 반전(exclusive or: XOR)
    - 100001(2)
    - 부호비트를 붙여준다.
    - 2의 보수에서 발생하는 carry bit는 버려준다.

​	

​	

## 실수

> 실수의 표현

소수점 이하 4자리를 10진수로 나타내보면



> 실수의 표현

- 컴퓨터는 실수를 표현하기 위해 부동 소수점(floating-point) 표기법을 사용한다
- 부동 소수점 표기 방법은 소수점의 위치를 고정시켜 표현하는 방식이다.
  - 소수점의 위치를 왼쪽의 가장 유효한 숫자 다음으로 고정시키고 밑수의 지수승으로 표현
  - 1001.0011 => 1.0010011 x 2^3^



> 실수를 저장하기 위한 형식

- 단정도 실수(32비트)
  - 부호1비트|지수8비트|가수23비트
- 배정도 실수(64비트)
  - 부호1비트|지수11비트|가수52비트
- 가수부: 실수의 유효 자릿수들을 부호화된 고정 소수점으로 표현한 것
- 지수부: 실제 소수점의 위치를 지수승으로 표현한 것



> 단정도 실수의 가수 부분을 만드는 방법

- 예: 1001.0011
- 정수부의 첫 번째 자리가 1이 되도록 오른쪽으로 시프트
- 소수점 이하를 23비트로 만든다
- 소수점 이하만을 가수 부분에 저장
- 지수 부분은 시프트 한 자릿수 만큼 증가 또는 감소



> 단정도 실수의 지수 부분을 만드는 방법

- 지수부에는 8비트가 배정(256개의 상태를 나타낼 수 있음)
  - 숫자로는 0-255까지 나타낼 수 있지만, 음수 값을 나타낼 수 있어야 하므로 익세스(excess) 표현법을 사용
  - 익세스 표현법: 지수부의 값을 반으로 나누어 그 값을 0으로 간주하여 음수지수와 양수지수를 표현하는 방법





> 컴퓨터는 실수를 근사적으로 표현한다.

- 이진법으로 표현할 수 없는 형태의 실수는 정확한 값이 아니라 근사값으로 저장되는데 이때 생기는 작은 오차가 계산 과정에서 다른 결과를 가져온다

 

> 실수 자료형의 유효 자릿수를 알아두자

- 32비트 실수형 유효자릿수(십진수) => 6
- 64비트 실수형 유효자릿수(십진수) => 15



> 파이썬에서의 실수 표현 범위

- 파이썬에서는 내부적으로 더 많은 비트를 사용해서 훨씬 넓은 범위의 실수를 표현할 수 있다.



> 참고: 재귀

- 내부 구조가 똑같이 생긴 서로 다른 함수를 호출한다고 생각하자
- 내가 현재 어디인지, 어디까지 가야 하는지 판단하자

```python
# 재귀 기본

def func(i, N):
    if i == N:
        return
    else:
        f(i+1, N)
```

```python
# A를 B에 복사
A = (10, 20, 30)
B = [0, 0, 0]

def func(i, N):
    if i == N:
        return
    else:
        B[i] = A[i]
        f(i+1, N)
        
```

```python
# A에 v=5가 있으면 1 리턴, 없으면 -1 리턴

def f(i, N, v):
    if i == N:				# 배열을 벗어난 경우, 검색 실패
        return -1
    elif A[i]==v:
        return 1
    else:					# 배열을 벗어나지 않고 검색 실패한 경우
        return f(i+1, N, v) # 리턴값을 다시 리턴
       

A = (7, 2, 5, 4, 1, 3)
N = len(A)
v = 5
print(f(0, N, v))
v = 9
print(f(0, N, v))
```

```python
# A => [0, 0, 0] 각 자리에 0 또는 1을 집어 넣는 경우


def func(i, N):
    if i == N:
        print(A)
    else:
        a[i] = 0
        func(i+1, N)
        a[i] = 1
        func(i+1, N)

def func2(i, N):
    if i==N:
        print(A)
    else:
        for j in range(2):
            A[i] = j
            f(i+1, N)
        
        
N = 3
A = [0] * N
func(0, N)
```

```python
# 1, 2, 3 중복사용해 3자리수 만들기

def f(i, N):
    if i == N:
        print(A)
    else:
        for j in range(1, 4):
            A[i] = j
            f(i+1, N)
            
N = 3
A = [0] * N
func(0, N)
```

```python
# 1~k 를 중복 사용해 3자리수 만들기
# 갈림길의 개수는 k에 영향, 깊이는 N에 영향

def f(i, N, k):
    if i == N:
        print(A)
    else:
        for j in range(1, k + 1):
            A[i] = j
            f(i+1, N, k)
            
N = 3
k = 5
A = [0] * N
func(0, N)
```

```python
# 1~k 를 중복 사용해 3자리수 만들기
# 세자리 수 v 값을 만들 수 있으면 중단하고 1 리턴, 없으면 0 리턴
# 111 <= v

def f(i, N, k, v):
    if i == N:
        s = A[0]* 100 + A[1] * 10 + A[2]
        # print(s)
        if s==v:
            return 1
        else:
            return 0
    else:
        for j in range(1, k + 1):
            A[i] = j
            # 다 돌지 않고 값을 발견시 return값을 이용해 중단하는 방법
            if f(i+1, N, k, v):
                return 1
        return 0
            
N = 3
k = 5
A = [0] * N
v = 123
func(0, N)
```

```python
# A의 부분집합중 합이 K인 부분집합의 개수 구하기
def func(i, N, s, K): # s i-1 원소까지 고려된 부분집합의 합
    global cnt
    if i==N:
        if s == K:  #끝에서 for를 돌려 합을 구할 필요 없어 시간단축
            cnt += 1
    elif s > K:
        return
    else:
        f(i+1, N, s + A[i], K) # A[i] 포함
        f(i+1, N, s, K)    


A = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
K = 55
cnt = 0
N = len(A)
f(0, N, 0, K)
```

