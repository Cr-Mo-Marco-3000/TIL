# String

- 문자열

- 컴퓨터에서의 문자표현
  - 비트맵으로 저장하는 방법은 너무 메모리 낭비가 심함
  - 각 문자에 대해서 대응되는 숫자를 정해 놓고 이것을 메모리에 저장함
  - 영어가 대소문자 합쳐서 52이므로, 6가지 비트(64가지)면 모두 표현할 수 있다. 이를 코드체계라고 한다.

​	

- 그런데 네트워크가 발전되기 전 미국의 각 지역 별로 코드체계를 정해 놓고 사용했지만
  네트워크(인터넷)이 발전하면서 서로간에 정보를 주고 받을 때 정보를 달리 해석한다는 문제가 생겼다.

- 그래서 혼동을 피하기 위해 표준안을 만들기로 했다.
- 바로 이러한 목적으로 1967년, 미국에서 ASCII(American Standard Code for Information Interchange)라는 문자 인코딩 표준이 제정되었다.

- ASCII는 7bit 인코딩으로 128문자를 표현하며 33개의 출력 불가능한 제어 문자들과 공백을 비롯한 95개의 출력 가능한 문자들로 이루어져 있다.
  - 화면에 출력되는 부분은 32번부터 126번까지 (빈칸), 특수문자, 숫자, 영어 대문자, 영어 소문자 순서로 나온다.
  - 다른 부분은 제어 문자들이다.
- 확장 아스키는 표준 문자 이외의 악센트 문자, 도형 문자, 특수 문자, 특수 기호 등 부가적인 문자를 128개 추가할 수 있게 하는 부호이다.
  - 표준 아스키는 7bit를 사용하여 문자를 표현하는 데 비해 확장 아스키는 1B 내의 8bit를 모두 사용함으로써 추가적인 문자를 표현할 수 있다.
  - 컴퓨터 생산자와 소프트웨어 개발자가 여러 가지 다양한 문자에 할당할 수 있도록 하고 있다. 이렇게 할당된 확장 부호는 표준 아스키와 같이 서로 다른 프로그램이나 컴퓨터 사이에 교환되지 못한다.
  - 그러므로 표준 아스키는 마이크로컴퓨터 하드웨어 및 소프트웨어 사이에서 세계적으로 통용되는 데 비해, 확장 아스키는 프로그램이나 컴퓨터 또는 프린터가 그것을 해독할 수 있도록 설계되어 있어야만 올바로 해독될 수 있다.
- 오늘날 대부분의 컴퓨터는 문자를 읽고 쓰는데 아스키 형식을 사용한다.
- 그런데 컴퓨터가 발전하면서 미국 뿐 아니라 각 나라에서도 컴퓨터가 발전했으며 각 국가들은 자국의 문자를 표현하기 위하여 코드체계를 만들어서 사용하게 되었따.
  - 우리나라도 아주 오래된 이야기지만 한글 코드체계를 만들어 사용했고 조합형, 완성형 두 종류를 가지고 있었다.

- 인터넷이 전 세계로 발전하면서 ASCII를 만들었을 때의 문제와 같은 문제가 국가간의 정보를 주고 받을 때 발생한다.
- 자국의 코드체계를 타 국가가 가지고 있지 않으면 정보를 잘못 해석 할 수 밖에 없었다.
  - 요즘은 자동으로 어느 국가에서 접속했는지 판단하여 처리한다.
- 그래서 다국어 처리를 위해 표준을 마련했는데, 이를 유니코드라 한다.
  - 유니코드 표준의 원본을 보고 싶다면, 도메인 주소에 .org가 붙는 사이트들을 찾으면 된다.
- 유니코드도 다시 Character Set으로 분류된다.
  - UCS-2(Universal Character Set 2)
  - USC-4(Universal Character Set 4)
  - 유니코드를 저장하는 변수의 크기를 정의
  - 그러나, 바이트 순서에 대해서 표준화하지 못했음
  - 다시 말해 파일을 인식 시 이 파일이 둘 중 어떤 것인지 인식하고, 각 경우를 구분해서 모두 다르게 구현해야 하는 문제 발생
  - 그래서 유니코드의 적당한 외부 인코딩이 필요하게 되었다.
- big-endian, little-endian
  - 메모리는 byte 단위로 주소가 구분이 된다. 즉 바이트 단위로 접근을 한다.
    - 1 byte는 0 ~255까지 구분될 수 있다(8bit)
  - 내부적으로 어떤 바이트를 먼저 저장하는지, 순서에 대한 차이점이다.
  - 예전에는 CPU에 따라 엔디안, 명령어들이 달랐다...

- 유니코드 인코딩(UTF)
  - 가변적임 - 표기는 최소 비트수를 얘기함
  - UTF-8(in web)
    - MIN: 8bit, Max: 32bit(1Byte * 4)
  - UTF-16(in Windows, java)
    - MIN: 16bit, Max: 32bit(2Byte * 2)
  - UTF-32(in Unix)
    - MIN: 32bit, Max: 32bit(4Byte * 1)

- python 인코딩
- 2.x - ASCII => `# -*- coding: utf8 -*-` 첫 줄에 명시 필요
- 3.X - 유니코드 UTF-8 => 생략 가능
- 다른 인코딩 방식으로 처리 시 첫 줄에 작성하는 위 항목에 원하는 인코딩 방식을 지정해 주면 됨



## 문자열의 분류

- 문자열
  - c와 java에서 분류 방식이 다르다.
  - Python은 java와 가깝다.

- java에서는, 문자열 앞에 hash값, 문자열의 길이 등 그 특성을 알려주는 추가적인 정보들이 같이 붙는다.
- C에서는, 문자열은 문자들의 배열 형태로 구현된 응용 자료형이다.
  - 문자배열에 문자열을 저장할 때는, 항상 끝에 문자열의 끝을 표현하는 널문자(\0)을 넣어준다.
    - java보다 C에서 메모리를 적게 쓴다.
    - 단 문자열을 다루는 기능들은 더 불편하다.
- 이전에 공부했듯이, string은 중간값만 수정이 불가능하다.

- strlen() 함수 만들어 보기

```python
def strlen(a):
    i = 0
    while a[i] != '\0':
        i += 1
    return i

a = ['a', 'b', 'c', '\0']

print(strlen(a))
```

- java(객체지향 언어)에서의 문자열 처리
  - 문자열 데이터를 저장, 처리해주는 클래스를 제공한다.
  - String 클래스를 사용한다.



- Python에서의 문자열 처리
  - char 타입 없음
  - 텍스트 데이터의 취급방법이 통일되어 있다.
  - 여러 문자열 기호들('', "", """, ''')과 +, * 등을 사용한다.
  - 문자열은 시퀀스 자료형으로 분류되고, 시퀀스 자료형에서 사용할 수 있는 인덱싱, 슬라이싱 연산들을 사용할 수 있다.
    - replace(), split(), isalpha(), find() 등
  - immutable한 자료형
- C와 Java의 String 처리의 기본적인 차이점
  - c는 아스키 코드로 저장한다.
  - java는 유니코드(UTF16, 2byte)로 저장한다.
  - 파이썬은 유니코드(UTF8)로 저장
- 다른 언어에선 swap을 위한 임시 변수가 필요하며, 반복 수행을 문자열 길이의 반만을 수행해야 한다.
- python은 reverse함수(string은 안됨: 리스트로 만든 후에) 혹은 slicing[::-1]을 이용해 구현 가능하다.
- 
- is와 ==의 차이
  - is: 같은 객체 참조
  - ==: 내용이 같음

- 붙어서 들어오는 문자열 처리

```python
a = map(int, input())
# input으로 들어오는 문자열은 iterable이므로
```



- 패턴 매칭에 사용되는 알고리즘들
  - 고지식한 패턴 검색 알고리즘
  - 카프 라빈 알고리즘
  - KMP 알고리즘
  - 보이어-무어 알고리즘
- 고지식한 알고리즘(Brute Force)
  - 본문 문자열을 처음부터 끝까지 차례대로 순회하면서 패턴 내의 문자들을 일일이 비교하는 방식으로 동작
  - 맨 마지막에 비교할 인덱스는 어디인가? N - M => 조건문에는 range(N-M+1) 해줘야 함
  - 시간복잡도 O(M * N)

```python
# if문을 하나만 쓰기 위해서

# i는 i - j를 해 주면 i - j + 1이 되므로 j와 비교했던 구간 처음부터 비교 
# j는 -1을 줌으로써 아래에서 +1을 해주면 0 => 처음부터 시작
```

- KMP 알고리즘
  - 불일치가 발생한 텍스트 스트링의 앞 부분에 어떤 문자가 있는지를 미리 알고 있으므로, 불일치가 발생한 앞 부분에 대하여 다시 비교하지 않고 매칭을 수행
  - 패턴을 전처리하여 배열 next[M]을 구하여 잘못된 시작을 최소화함
    - next[M]: 불일치가 발생했을 경우 이동할 다음 위치
  - 시간 복잡도: O(M+N)
  - 구현
    - 매칭이 실패했을 때 돌아갈 곳을 계산한다.



- 패턴의 맨 앞에서 불일치
  - 일치시 i+1, j+1
  - 불일치 i = next[j]



- 빅 오 표기는 최악의 경우 이정도
- 세타는 항상 이 정도





연속한 1의 개수

```python
for tc in range(T):
    N = int(input())
    arr = list(map(int, input()))
    count = 0
    # if 안에 max= count를 뺐을 때, 마지막에 1로 끝날 때 해결방안
    # else 안 구문을 마지막에 한번 더 붙인다.
    # 문자열 마지막에 0을 붙인다.
    for i in range(len(arr)):
        if arr[i] == 1:
            count += 1
            max = count
        else:
            if max < count:
                max = count
            count = 0
            
    print(~~~)
```



고대유물

당근





KMP 알고리즘 정리:

- 접두사, 접미사
  - e. g. banana
    - 앞 두글자 / 세글자 / 네글자
      - 접두사: b / b, ba / b, ba, ban/
      - 접미사: a / n, an / a, na, ana
- 패턴 : AABAABAC
  - AAB
    - 접두사: A, AA
    - 접미사: B, AB
    - 일치하는 것 없음
  - AABA
    - A, AA, AAB
    - A, BA, BAB
    - A 일치
  - AABAA
    - A, AA, AAB, AABA
    - A. AA, BAA, ABAA
    - 일치 중 가장 긴 것: AA
  - AABAAB
    - AAB, AAB 일치
  - AABAABA
    - AABA 일치
  - Pattern Index(PI): Pi 0 1 0 1 2 3 4 0
    - 숫자의 의미: 어떤 요소가 있을 때, 접두사와 접미사가 최대 길이로 일치하는 값.



- 불일치가 발생 시, 불일치가 발생 한 바로 앞으로 가서, 일치하는 부분까지 땡김



디버거는 어디에 걸까?

함수가 시작되는 부분에 건다.

global frame을 나눌 수 있다.

그 다음 다음에 실행될 곳으로 가고 싶다. 

=> 함수 프레임 안으로 들어갈 수 있다.

=> 함수 안에서 전역 변수를 보려면, + 누르고 전역변수 입력

F8 함수 뛰어넘기

shift + F8 함수 탈출