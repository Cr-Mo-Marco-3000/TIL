# 배열

- 배열이란 **하나의 이름으로 참조**되는 **같은 자료형**을 가진 메모리의 **연속적인** 공간, 데이터들의 집합을 말한다.



## I. 1차원 배열

- 배열은 선언되면 원소의 수만큼 메모리에 할당을 받게 된다.
- 배열 내부의 각 원소를 배열 원소라 부른다.
- 형식
  - `type arrayName[size];`
- 배열은 원소들이 연속된 기억장소에 할당하게 된다.
- 할당된 각 원소의 위치를 열이라고 한다.
- 1차원 배열은 열의 집합이다.

- **첨자가 없는 배열명은, 배열의 첫번째 원소의 주소, 즉 배열이 할당된 메모리의 시작주소를 갖는 포인터 상수이다.**
  - 즉, `&배열명[0]`과 같다.


```c
#include <stdio.h>

int main(void) {
	int myArray[5] = { 1, 2, 3, 4, 5 };
	int i;
	printf_s("메모리 주소: %p \n", myArray); // 배열의 첫 번째 원소 주소와 동일
	for (i = 0; i < 5; i++) {
		printf_s("배열값: %d, 메모리 주소: %p \n", myArray[i], &myArray[i]);
	};

	return 0;
}
```



### 1. 배열의 원소 접근

- 첨자(subscript) 또는 인덱스(index)를 주어 해당 원소 위치에 값을 대입할 수 있다.
- 모든 배열은 0부터 시작한다.
- 배열 자체를 명시하려면, 선언 이후부터는 **배열명만 적어 주어도 된다**.

```c
int main(){
    
    int count[5];
    int i;
    
    printf("배열의 전체크기 %d, 하나의 원소크기 %d\n",
          sizeof(count), sizeof(count[0]); // 각각 20, 4가 나옴
}
```



### 2. 선언과 초기화

- 배열 초기화
  - `int arrayName[5] = {100, 200, 300, 400, 500};`
- 배열은 선언하고 초기화하지 않으면, 스택 영역에 할당된 배열은 쓰레기 값을 저장하고 있다.

- 초기화를 할 때 인덱스 0부터 채워지게 되고, **채워지지 않은 인덱스에는 0이 들어간다.**
  - `int arrayName[5] = { 100, 200, 300 };`
  - 3, 4열에는 0이 들어감

- 모든 원소를 0으로 초기화하는 법
  - 1차원 배열
    - `int zeroArray[100] = {0};`

  - 2차원 배열
    - `int zeroArray[100][100] = {0};`
  
- **선언 이후 인덱스로 접근하지 않고 배열 통째로 할당하는 방법은 불가능하다.**
  - 1-6절 참고

```c
int main(void) {
	
    // 불가능
    int myArray[5];
	myArray = { 2, 3, 4, 5, 6 }; 
    
	return 0;
}
```



### 3. 원소의 값, 주소 반환

- 값 반환
  - `arrayName[i]`
- 주소 반환
  - &`arrayName[i]`



### 4. 배열 사용시 주의사항

1. **배열의 크기는 상수로 선언한다(변수 X).**
   - 컴파일 타임에는 컴파일러가 변수나 배열의 크기를 확인하는 단계.
     - 컴파일 타임에는 변수의 할당이 일어나지 않고, 변수의 할당은 런타임(실행중)에 일어난다.
     - 즉, 컴파일 타임에 컴파일러는 변수의 값을 알 수 없기 때문에 오류가 일어난다!
   - 단, 동적할당일 때는 크기를 변수로 줄 수 있다.

```c
int a1[5];
int a3 = 5;
// int a4[a3]; 불가능하다!
const int a5 = 5;
// int a6[a5]; 얘도 불가능하다.
// int a7[]; // 오류: 배열의 크기가 없다.
```



2. 배열 인덱스의 유효범위는 0 ~ (배열크기 - 1)이다.
   - 위반할 시 **로직 오류가 발생**한다.



3. c언어는, 배열의 경계를 체크하지 않는다.
   - 즉, 해당 배열에 주어진 크기를 넘어가는 메모리에게도 접근 - 출력은 가능하다.
   - 다만, 권한이 없는 메모리에 값을 저장하려고 할 때는 **런타임 에러가 발생할수도 있다.**

```c
// by 종오
#include <stdio.h>
#define SCORE_ARR 9
int main()
{
	int score[SCORE_ARR], i;
	// int sum = 0, max, min;
	for (i = 0; i < SCORE_ARR-4; i++)
	{
		printf("%d, input : ", i + 1);
		scanf("%d", &score[i]);	//530, 30,
	}
	score[5] = score[6] = score[7] = score[8] = 0;
	//score[7] = score[0];
	//score[8] = score[0];
	for (i = 0; i < SCORE_ARR; i++)
		printf("%d\t", score[i]);
	for (i = 0; i < SCORE_ARR-4; i++)
	{
		score[5] += score[i];
		if (score[i] > score[7])
			score[7] = score[i];
		if (score[i] < score[8])
			score[8] = score[i];
	}
	score[6] = score[5] / 4;
	for (i = 0; i < SCORE_ARR; i++)
		printf("%d\t", score[i]);
	printf("\n");
	printf(" 합 : %d\t 평균 : %.2f\n 최대값 :%d \t 최솟값 : %d \n", score[5], score[6], score[7], score[8]);
}
```

4. 배열을 선언할 때는 넉넉하게 선언해 주어야 한다.
   - 공간이 모자른 것 보다 넘치는 게 낫다

### 5. 배열에 데이터 입력

- `scanf()` 함수를 이용한다.
- 각 원소의 메모리 주소에 입력값을 할당한다.

```c
#include <stdio.h>

int main(void) {
	int myArray[5];
	int i;
	for (i = 0; i < 5; i++) {
		printf_s("입력할 수?");
		scanf_s("%d", &myArray[i]);
        
        // 코드낭비
        // scanf_s("%d", &temp);
		// myArray[i] = temp;
	};

	for (i = 0; i < 5; i++) {
		printf_s("인덱스 %d의 원소: %d \n", i, myArray[i]);
	};
	return 0;
}
```



### 6. 배열 전체 치환 불가능

- 배열의 구조가 같더라도, **배열 전체를 다른 배열로 한번에 치환할 수 없다.**

- **하나의 배열을 다른 배열로 복사하기 위해서는 각각의 원소를 하나하나 대입해 주어야 한다.**

- 불가능
  - `int x[3] = {1, 2, 3}; int y[3]; y = x`



### 7. 언사이즈드 배열

- `int myArray[] = {1, 2, 3, 4, 5};`
- **1차원 배열을 초기화** 할 때는 **배열의 크기를 지정할 필요가 없다.**
- 크기를 지정하지 않으면, 컴파일러는 초기화 상수의 개수를 세어 그 개수를 배열의 크기로 사용한다.
- 이렇게 선언된 배열을 언사이즈드 배열이라고 한다.
- **물론, 언사이즈드 배열을 사용할 때는 초기화가 필수이다.**



### 8. Designated Initializer

- 특정 인덱스에만 값을 지정하고, 나머지는 0으로 만들어주는 방법

- 예시

  - `int array[10] = { [2] = 5, [5] = 10};`
    - 3열과 6열에 값을 지정하고 나머지는 0으로 초기화
  - `int array[10] = { [5] = 10, [2] = 5 };`
    - 위와 상동
    - 열을 서술하는 순서는 상관없다.
    - 더 뒤에 있는 열이 앞에서 지정되도 된다.

  - `int c[10] = {5, 1, 9, [4] = 3, 7, 2, [8] = 6};`
    - 기존의 방법과 섞어서 사용
    - 섞어 쓸 때는, 맨 처음에는 인덱스 0부터 값이 들어가다가 지정 초기자를 만나면, 그 다음부터는 해당 인덱스를 기준으로 다음 인덱스부터 값이 들어간다.
    - `int a[15] = { 1, [14] = 48, [9] = 7, 3, [2] = 29, 3 };`
      - `1, 0, 29, 3, 0, 0, 0, 0, 0, 7, 3, 0, 0, 0, 48`
      - `[14] = 48 뒤에 , 3를 넣으면 에러 발생(15열은 없기 때문)`

- 2차, 3차원 배열에도 사용 가능하다.

  - `int str[5][5] = {[0][0] = 1, [2][1] = 2};`
  - 0,0에 1, 2,1에 2를 넣고 나머지는 0으로 초기화



### 예시: 배열을 사용한 최대값 최소값 구하기

```c
#include <stdio.h>

int main(void) {
   
    int myArray[5];
    int i;
    int min, max;
    for (i=0; i < 5; i++) {
      	printf_s("입력할 수?");
		scanf_s("%d", &myArray[i]);
    }
    
    min = max = num[0];
    
    for (i=0; i < 5; i++) {
    	if (max < num[i]) {
            max = num[i];
        }
        if (min > num[i]) {
            min = num[i];
        }
    printf("최대값: %d, 최소값: %d", max, min);
    }
    return 0;
}
```

### 예시: 배열 크기를 이용한 배열 순환 기법

```c
#include <stdio.h>

int main(void) {
    int myArray[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }, i;

    // 배열 크기를 이용하여 배열을 순환한다.
    // sizeof는 할당된 메모리 크기를 반환하므로, 사용해도 된다
    // 컴파일러가 경고를 띄울수도 있는데, sizeof는 sizeof_t라는 무부호 정수형을 반환하기 때문이다. 
    // => 이럴때는 (int) sizeof(myArray) / sizeof(myArray[0]) 를 사용해 해결할 수 있다.
    for (i = 0; i < sizeof(myArray) / sizeof(myArray[0]); i++) {
        printf("%d, ", myArray[i]);
    }

    return 0;
}
```



## II. 다차원 배열

- 예를 들어, 여러 명의 이름을 저장한다고 생각하자.
- c에서의 문자열은 배열이기 때문에, 1차원 배열로는 불가능하다.
- 배열 안의 배열인 다차원배열을 사용하자.
- 선언
  - `자료형 배열명[n][m]`
  - n x m 배열을 만든다.
- n번째 행, m번째 열에 접근하려면
  - `배열명[n-1][m-1]`으로 접근한다.

### 1. 다차원 배열이 메모리에 저장되는 방법

- c에서는 배열을 행 우선 순서로 저장한다.

- 즉 1행[1열, 2열, 3열, ...], 2행[1열, 2열, 3열, ...], ... 3행[1열, 2열, 3열, ...]... 순서로 저장된다.



### 2. 다차원 배열 초기화

- 일차원 배열 내에 일차원 배열을 넣어 초기화 가능

- 다차원 배열에서의 배열 인덱스의 의미

  - n차원 배열에서는 n번째 적힌 첨자의 인덱스만이 **원소값**을 의미하고, n-1번째 첨자부터 배열명까지는 해당 내부 배열이 시작되는 **주소값**을 의미
    - 문자열에서 변수명으로 주소값을 지칭할 수 있는 이유(scanf와 gets에서)도, 문자배열은 1차원 배열이기 때문이다.


  - 2채원 배열 예시

    - `배열명`
      - 해당 배열의 시작 **주소값**


    - `배열명[행]`
      - 각 행의 시작 **주소값**
      - **1차원 배열에서는, 값이기 때문에 주의해야 한다!**


    - `배열명[행][열]`
      - 각 열의 **원소값**
    
      - 주소를 구하려면 `&배열명[행][열]`

- 배열의 깊이를 판단할때는 선언문을 보고 1차원 배열인지 2차원 배열인지 파악해야 한다.

  

- 예시

```c
int str[3][4] = {{1, 2, 3, 4},
                 {5, 6, 7, 8},
                 {9, 10, 11, 12}};
```

- 다양한 선언 방법
  - 단, 다차원 배열의 초기자에서 중괄호를 생략하는 것은 상당히 위험한 일이다.

```c
// 4행부터는 모두 0으로 초기화
int str[5][5] = {{1, 2, 3, 4, 5},
                 {5, 6, 7, 8, 10},
                 {9, 10, 11, 12, 11}};

// 2, 3행의 4열부터는 모두 0으로 초기화
int str[5][5] = {{1, 2, 3, 4, 5},
                 {5, 6, 7},
                 {9, 10, 11},
                 {8, 10, 11, 24, 3},
                 {9, 10, 12, 19, 8}};
// 내부 중괄호를 생략해도 들어간다.
int str[5][5] = {1, 2, 3, 4, 5,
                 1, 2, 3, 4, 5,
                 1, 2, 3, 4, 5,
                 1, 2, 3, 4, 5,
                 1, 2, 3, 4, 5,}

// 0,0에 1, 2,1에 2를 넣고 나머지는 0으로 초기화
int str[5][5] = {[0][0] = 1, [2][1] = 2};
```

### 3. 상수 배열

**배열은 많은 경우 프로그래밍 도중 바뀌지 않기 때문에 주로 const로 상수화시킨 상수배열을 사용한다.** 컴파일러가 오류를 잡아줄 수 있게 말이다.



### 4. 가변 길이 배열

- 원래 배열의 크기는 상수로 정의해야 한다.
- 그런데 C99에서는 이를 변수로 지정할 수 있도록 해놓았는데, 이를 가변길이배열이라고 한다(Variable-length Array)
  - 비주얼 스튜디오틑 C90을 따른다.
- 근데 C11에서는 또 빠짐
