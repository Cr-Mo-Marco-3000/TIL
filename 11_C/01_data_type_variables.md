# 자료형과 변수

## I. C 언어 기본 자료형과 변수

### 1. 자료형이란?

- 컴퓨터가 처리할 수 있는 데이터의 종류(컴파일러에게 데이터 종류와 메모리 공간의 크기 등을 구분)

### 2. 기본 자료형의 종류

1. 문자형
   - char
2. 정수형
   - short
   - int
   - long
3. 실수형
   - float
   - double
   - long double
4. 기타
   - void

#### 2-1. 문자형

- char형
- 1바이트(8비트)
  - 한 문자를 저장
- 작은따옴표로 묶어서 서술
  - 문자열은 큰따옴표
- 아스키(ASCII)코드 값을 1바이트 정수 형태로 가지고 있음
  - 아스키는 128개의 가능한 문자조합을 제공하는 7bit 부호
  - 0 ~ 127까지는 일반 문자, 128부



#### 2-2. 정수형

- 정수 값은 크기에 따라 2바이트, 4바이트, 8바이트로 구성
- 크기별로 short, int, long으로 표현
  - 각각 할당되는 메모리 공간은 운영체제의 bit에 따라 다름



#### 2-3. 실수형

- 소수 등을 표현하는 수
- C언어에서는 부동형(실수형을 사용할 수 있도록 해줌)
- float: 4byte, double: 8byte



#### 2-4. void형

- 값이 없음
- 값을 갖지 않는 특수한 형태
- 값을 갖지 않는 것을 명시하는 목적으로 사용
- 함수를 정의, 선언할 때 주로 사용



### 3. 변수 선언과 값의 치환

- 변수는 다양한 값을 저장할 수 있는 이름이 부여된 메모리 기억장소
- 선언과 동시에 메모리에 필요한 공간을 할당받음
- **역사적으로, C에서는 프로그래머들에게 해당 블록에 쓰이는 모든 변수를 블록 처음에 선언하고 사용하도록 하고 있다.**

#### 1. 변수의 선언

- 형식
  - `type var_name;`

#### 2. 변수 값의 치환

- `=`를 사용하여 변수에 값을 저장하는 것을 치환이라고 함
- 실수형 상수는 기본적으로 double로 변환되어 사용되는 규칙이 있다.
- `float fnum = 5.3;`
  - 우측은 double이므로, float로 변환되어 저장된다는 경고가 뜸

### 4. printf() 함수의 또 다른 기능

- %

  - 형식 지정자(자료형 지정자)
  - 문자열 내부에 사용

- 특정 **변수를 형식지정자의 자료형에 맞춰서 출력**하고 싶을 때 사용한다.

  - 즉, 해당 자료형이 아니더라도, 해당 형식대로 출력되기는 한다.
  - 다만, `%s`같은 경우는, 문자열은 배열이므로 오류가 날 수 있음에 주의!

- 사용

  - `prinf("출력형식지정자, 출력값")`

- 종류

  - `%c`
    - 한 문자 출력
  - `%s`
    - 문자열 출력
  - `%d`
    - 부호 있는 10진수 출력
  - `%f`
    - 부동 소수점 형식 출력(float형)
  - `%lf`
    - 부동 소수점 형식 출력(double형)

  - %%
    - `%`를 출력할 때 사용

- 주의!

  - printf는, 인자로 문자 또는 문자열만을 받는다!

### 5. sizeof()

- 피연산자의 **할당된 메모리 크기**를 반환한다.

```c
/*
sizeof(자료형)
sizeof(변수명)
sizeof 변수명
*/
```

### 6. 상수

- 프로그램에 의해서 변경되지 않는 고정된 값

- 사용할 때는 초기화(선언과 동시에 값을 할당)해야 한다.

- 종류

  1. 기호상수

     - 변수처럼 이름을 갖는 상수를 의미

     - 변수처럼 선언하며 키워드 const 추가
     - 변수와 같이 값이 할당됨
     - 값 변경 불가

  2. 리터럴 상수

     - 이름을 갖지 않는 상수
     - 형식
     - `int x = 100;`에서 100 부분이 리터럴 상수

#### 1) const 변수

- 변수를 상수화시킨 것
- 변수의 자료형 앞에 const 키워드 사용
- `const 자료형 변수 = 초기화 값;`
- 사용과 동시에 초기화가 필요하다.



#### 2) 매크로 상수(define) / 매크로 함수

- `#define`으로 정의
- #로 시작되므로 **문법을 해석(컴파일)하기 전**에 **전처리기에 의해 해석됨**(#include와 비슷)
  - 세미콜론으로 끝나지 않음(세미콜론 붙이면 에러)!
- 형식
  - 매크로 상수
    - `#define 상수명 값`
  - 매크로 함수
    - `#define 함수명(인자1, 인자2...) 함수내용`

- 전처리기는, 해당 상수 / 함수들을 코드 내부에서 매크로 값으로 모두 대치



#### 3) 접미사 규칙

프로그램에서 상수를 이용할 때, 컴파일러는 그 상수의 형을 무엇인지 결정한다. 

C 컴파일러는 고정소수점 상수는 int형으로, 부동소수점 상수는 double형으로 변환하여 사용한다.

만약 수치 상수에 잠정적으로 결정된 형을 원하는 것이 아니라면, 접미사를 통해 정확한 형을 지정할 수 있다.

```c
#include <stdio.h>

int main() {
    float fnum = 5.3;  // 좌측을 double로 해석하여 'double'에서 'float'(으)로 잘린다는 경고가 뜸
	float fnum = 5.3F; // F를 통해 상수의 형을 float로 결정

	return 0;
}
```

- 상수 접미사 구분

| 상수  | 접미사 없음 | 접미사 있음  |
| ----- | ----------- | ------------ |
| 3.10  | double      |              |
| 3.10F |             | float        |
| 3.10L |             | long double  |
| 100   | int         |              |
| 100L  |             | long int     |
| 100U  |             | unsigned int |



## II. 변수 초기화와 주소 연산자

- 변수를 선언하면 해당 변수는 메모리 공간을 할당 받는다
- 변수는 일반적으로 stack이라는 재활용 공간에 할당된다.
  - 이 공간의 메모리는 **재활용되는 공간**이다.
  - 따라서, 변수에 값을 할당하지 않으면 어떤 값이 남아 있는지 알 수 없다.
  - 즉, 원하지 않는 임의의 값인 쓰레기 값이 저장되어 있다.

- 쓰레기가 저장되어 있는 이유
  - 메모리는 계속 재활용을 하는데, 응용 프로그램이 변수의 공간을 요청하면 운영체제가 현재 사용하지 않는 빈 공간을 찾아 넘겨준다. 그런데 이때, 반환하는 메모리 공간에 이전에 사용한 값들이 그대로 남아있고 운영체제도 이를 0으로 만들지 않고 넘기기 때문에 쓰레기가 남아있는 것이다.
- 누적변수 사용
  - 누적변수는 다른 값들을 더한 값이 누적되는 변수이다.
  - 누적변수는 반드시 0으로 초기화되어야 한다. 그렇지 않으면 알 수 없는 값이 나오게 된다.

```c
int a, b, sum = 10;

a = 100, b = 200;
sum = sum + a;
sum = sum + b;

printf("%d", sum); // 300
```

### 1. 변수와 주소 연산자

메모리는 메모리 주소에 의해 관리된다.

메모리는 바이트 단위로 관리되며, 메모리에 할당되는 모든 것은 주소를 갖는다.

변수가 선언되면 메모리에 할당되며, 모든 변수는 메모리 주ㅗ에 의해 구분되어 저장된다.

-  &
  - 주소 연산자
  - 연산자 뒤에 오는 변수의 할당된 메모리 **시작번지를 반환**

```c
#include <stdio.h>

int main() {
	char ch = 'A';
	int num = 50;
	double dnum = 1.5;
	float fnum = 5.3;

	printf("%p, %p, %p, %p \n", sizeof(&ch), sizeof(&num), sizeof(&dnum), sizeof(&fnum)); // 할당된 주소

	return 0;
}
```



### 2. 데이터 입력, scanf()

- %해당 형식 지정자에 해당하는 정보를 사용자에게 키보드로 입력받아, 변수에 저장
- 첫 번째 인자로는 입력받을 데이터 형식을, 두 번째 인자로는 **메모리 주소**가 들어간다
  - 첫 번째 인자에 해당하는 데이터를 입력받아 두 번째 인자의 메모리 주소에 저장
- 형식
  - `scanf("형식지정자", &변수명1, &변수명2, ...)`
- 주의!
  - scanf() 함수는 표준 라이브러리 함수이다.
  - 어떤 상황에서는 안전하지 않으므로 비주얼 스튜디오에서는 대신 scanf_s()를 사용하길 권장한다.

```c
#include <stdio.h>

int main() {
    char gender;
    int age;
    double height;
    
    prinf("성별?");
    scanf("%c", &gender);
    prinf("나이?");
    scanf("%age", &age);
    prinf("신장?");
    scanf("%height", &height);    
        
    return 0;
}
```



## III. 자료형 수정자

void를 제외한 기본 자료형은 C의 형(자료형) 수정자(type modifier)를 사용하여 좀 더 적합한 형태로 수정하여 사용할 수 있다.

- 종류
  - short
  - long
  - signed
  - unsigned
  - long long(__int64)
    - 32비트 환경에서만 적용



### 1. short, long 수정자

- short와 long 수정자는 **int형에 적용**된다.
- 일반적인 규칙에서, short int는 int보다 적은 메모리 크기를 할당받고, long int는 int보다 큰 메모리 크기를 할당받는다.
- 다만, 정확히 얼마나 할당받는지는 운영체제 환경에 따라 다르다.

```c
int x;
// short나 long이 붙었을 때 int는 생략 가능하다
// 즉 다음 코드와 아래 코드는 같은 코드이다. short y;
short int y;
short z;
```

- 운영체제 환경에 따른 크기
  - `long long(__int64)`
    - 32비트 환경에서 8바이트를 할당하기 위해 사용하는 수정자

|       | 16bit OS 환경 | 32bit OS 환경 | 64bit OS 환경 |
| ----- | ------------- | ------------- | ------------- |
| short | 2             | 2             | 2             |
| int   | 2             | 4             | 4             |
| long  | 4             | 4             | 8             |



### 2. signed와 unsigned 수정자

- **char, int 형에 적용**된다.

- 변수는 선언 시 기본적으로 signed가 기본이며, unsigned는 따로 명시해 주저야 한다.
- **signed 수정자**는 **부호가 있는 정수**를 나타낼 때 사용된다.
  - 즉, 기본적으로 변수는 부호가 붙어서 선언된다.
- unsigned 연산자를 붙이면 무조건 0 또는 양수를 나타내기 때문에, 부호를 나타낼 필요가 없어진다.
  - 즉, 부호 비트자리에 정보를 저장할 수 있어서, 표현 가능한 숫자 / 범위가 양수 쪽으로 더 늘어난다.
- 음수부분이 불필요한 경우 unsigned를 사용하면 효율성을 높일 수 있다.
  - 임베디드 쪽에서 사용한다.

### 3. signed와 unsigned의 차이

signed와 unsigned의 차이는 정수의 **최상위 비트를 해석하는 방법**에 있으며, 음수를 사용하지 않는 경우 메모리 할당의 크기는 그대로 유지하면서 값의 범위를 양수로 약 2배정도 더 크게 표현할 수 있는 이점이 있다.

| 자료형(정수)   | 비트수    | 범위                                 |
| -------------- | --------- | ------------------------------------ |
| short          | 16        | -32768 ~ 32767                       |
| unsigned short | 16        | 0 ~ 65535                            |
| int            | 32(or 16) | -32768 ~ 32767<br />-2^31^-1 ~ 2^31^ |
| unsigned int   | 32(or 16) | 위와 비슷함                          |
| long           | 32(or 64) | 위와 비슷함                          |
| unsigned long  | 32(or 64) | 위와 비슷함                          |

### 4. 자료형의 overflow와 underflow



## 음수의 표현

C에서는 일반적으로 음수를 2의 보수로 표현

2의 보수는 부호 비트를 제외한 모든 비트를 반대로 바꾸고, 그 값에 1을 더하는 것

## IV. 자료형 변환

자료형 변환은 **int형 데이터가 float형**으로, 또는 **float형 데이터가 다른 형**으로 변환되는 것을 말한다.

형변환은 묵시적 형변환과 명시적 형변환이 있다.

### 1. 수식에서의 형 변환

#### 1. 묵시적 형 확장

C컴파일러는 수식을 처리할 때 피연산자들의 자료형이 다르면 두 피연산자 중에서 큰 피연산자의 형으로 나머지 자료형을 자동 형변환한다.

두 피연산자들은 같은 형을 가지게 되고 그 결과는 두 피연산자의 형과 같다.



질문 

1. %d에 char는 집어넣어도 왜 괜춘? 예외?

   - 메모리에 집어넣는 형식이 완전히 동일하기 때문

   - 예를 들어 float는 지수, 기수부로 나누어지기 때문에 아예 저장하는 형식이 다르고, 그래서 정수를 %f에 넣었을 때 인식을 못하는 것

2. 메모리에 값 저장시에는 앞에서부터, 다른 변수에 대입시에는 뒤에서부터?
   - 숫자를 메모리에 저장할 때는 오른쪽부터 저장
   - 문자를 메모리에 저장할 때는 왼쪽부터 저장

- 
