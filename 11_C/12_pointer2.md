# 포인터 심화

## 1. 배열 이름 포인터로서 쓰기

- 포인터의 이름은, 배열의 첫 번째 원소를 가리키는 포인터로 사용될 수 있다.
  - 즉, `matrix[r][c]`에서 matrix는 matrix[0]을 가리키는 포인터(즉 `&matrix[0]`와 같다.)이고, `matrix[0]`는 `matrix[0][0]`을 가리키는 포인터이다.
  - **단, 두 가지의 경우는 배열의 첫 번째 원소가 아니라 해당 배열을 가리킨다.**
    1. **sizeof() 연산자와 함께 쓰이는 경우, 해당 배열 자체의 size를 반환.**
    2. **&연산자와 같이 쓰이는 경우, 해당 배열 자체를 의미**
  - 여기서 원소란, 가장 작은 단위의 원소가 아닌 한 차원 아래의 원소, 이를테면 2차원 행렬에서의 행을 말한다.

```c
#include <stdio.h>

int main() {

	char arr[3][3];

	printf("3x3 배열의 시작위치: %p\n",arr);
	printf("배열의 이름 - 첫 번째 원소(행)에 + 1: %p\n", arr + 1);
	printf("배열 전체의 크기만큼 더하기: %p", &arr + 1);

	return 0;
}
```

- **즉, `a[i] => *(a+i)`이고, 실제로 컴파일러 내부에서 해당 변환을 수행한다.** 

```c
// 첨자 변환 실험

#include <stdio.h>

int main() {
	int array[3][4];

	// *(array+2) ==  &*(*(array+2) + 0)
	printf("%d", array[2] == &array[2][0]);

	// **(array+2) == *(*(array+2)+0)
	printf("%d", *array[2] == array[2][0]);
}
```

- 배열의 이름을 포인터로 쓰는 것처럼, 포인터에 첨자를 붙여 사용할 수도 있다.

```c
int array[5] = {1, 2, 3, 4, 5};
int *ptr;
ptr = array;
printf("%d", ptr[2]); // == *(ptr+2) == 3
```

### 포인터와 배열명

앞에서, 배열의 이름은 해당 배열 원소의 첫 번째를 가리키는 포인터로 사용될 수 있다고 하였다. 이 말은, 이를테면 2차원 배열에서 배열명은 첫 번째 행을 가리키고, 배열명[행]은 첫 번째 열 - (1,1)을 가리킨다는 것을 의미한다.

이는 다음과 같이 증명할 수 있다.

```c
int *ptr;
p = &arr[i][j]; // i행 j열을 가리키는 포인터
// p = &*(arr[i]+j)
// j에 0을 대입
// &*(arr[i])
// &과 *는 서로 상쇄됨
p = arr[i]
```

또, 앞에서 말했듯이 &를 붙이면 첫 번째 원소가 아닌 배열 자체를 가리키게 된다.



## 2. 배열 포인터 변수

다차원 배열 포인터 변수란, 다차원 배열에서 특정 단위 - 이를테면 면 혹은 행에 접근할 때 사용하는 포인터 변수를 말한다.

- 포인터 자체의 크기는 4byte 혹은 8byte이다.
- 이를테면, 2차원 배열의 행에 접근하고 싶을 때, 해당 포인터가 몇 byte씩 건너뛰어야 각 행에 접근할 수 있는지 컴퓨터는 파악이 가능하다.
  - 예를들어 char 4 X 4 배열은 메모리에 일직선으로 저장되므로, 각 행에 접근하기 위해서는 4씩 건너뛰어 접근해야 한다.
- 따라서 2차원 배열 포인터에는 열이 들어가야 하고, 3차원 배열 포인터에는 행과 열이 들어가야 한다.

```c
#include <stdio.h>

int main() {
	int array[4][4][4];
	
	int *ptr; // 1차원 배열 포인터
	int (*ptr2)[4]; // 2차원
	int (*ptr3)[4][4]; // 3차원
	
	printf("%d, %d, %d, %d, %d, %d", 
		sizeof(ptr), sizeof(ptr2), sizeof(ptr3), sizeof(*ptr), sizeof(*ptr2), sizeof(*ptr3)); // 4, 4, 4, 4, 16, 64
}
```

- 배열 포인터 변수에 포인터 넣기
  - 배열 포인터 변수에 포인터를 넣을 때는, 포인터 형식을 맞춰 주어야 한다.
  - 이는 단순히 int형 같은 의미일 뿐 아니라, 해당 포인터에 배열의 열 크기를 정확히 맞춰서 넣어 주어야 한다는 것을 의미한다.


```c
#include <stdio.h>

int main() {
	int array[3][4][5] = { 0 };
	
	// 1차원 배열 포인터 변수
	int *ptr1;
	// 1차원 배열 포인터에 저장 => 배열변수는 해당 배열의 첫 번쨰 원소를 의미 => 배열의 첫 번째 원소 즉 3면 4행 1열의 주소를 저장
	ptr1 = array[2][3];
	// 아니면 & 연산자를 붙여 직접 넣어주기 가능 => 3면 4행 1열의 주소를 저장
	ptr1 = &array[2][3][0];

	// 2차원 배열 포인터 변수
	int (*ptr2)[5];
	ptr2 = array[2]; // 2차원 배열 포인터에 저장 => 배열의 첫 번째 원소 즉 3면 1행을 가리킴
	ptr2 = &array[2][0]; // & 연산자를 통해 2차원 배열 포인터에 저장 => 배열의 첫 번째 원소 즉 3면 1행을 가리킴


	puts("===============================================================");

	int array2[3][4] = { 0 }; // 2차원 배열 선언

	int(*ptr3)[3];
	int(*ptr4)[4];

	ptr3 = array2; // 컴파일 에러 => array2는 열크기가 4인데 ptr3는 3임

	// 아래 두 방법과 같이 할당이 정확함
	ptr4 = array2;
	ptr4 = &array2[3];
}
```

- 아래는 전혀 문제가 없다.

```c
#include <stdio.h>

int main() {
	int array[3][4] = { 0 };

	int (*ptr)[4]; // 행을 가리키는 포인터

	ptr = array; // array == &array[0] 이므로
}
```



## 3. 이중 포인터를 이용한 배열 원소 접근

- **다차원 배열 포인터 변수에 *를 붙이면, 해당 포인터 내부의 원소를 가리키는 포인터로 전환된다.**
  - **포인터이므로, 포인터 연산이 가능하다**.
- 이차원 배열의 첨자를 포인터 연산식으로 변형하면 다음과 같다.
  - `ptr[i][j] == *(*(ptr+i)+j)`
- 증명은 다음과 같다.

```c
#include <stdio.h>

int main() {
    int count[3][4] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 };

    int(*ptr)[4]; // 2차원 배열

    int i, j;

    // 증명
    ptr = count;
    // ptr == count ==  &count[0]
    // *ptr == *(&count[0]) == count[0] == &count[0][0] // 첫 번째 행, 첫 번째 열의 포인터

    // 따라서, 아래와 같은 식이 성립된다.
    for (i = 0; i < 3; i++) {
        for (j = 0; j < 4; j++) {
            //아래 두 식은 같다.
            printf("%p, %d == ", ptr[0] + j, ptr[0][j]);
            printf("%p, %d\t", *ptr +j, *(*ptr + j));
        }
        ptr++; // 행을 하나씩 증가
        puts("");
    }

}
```



## 4. 포인터 배열



## 5. 이중 포인터



## 6. 제네릭 함수 : void형 포인터

- C언어 표준에서는 NULL 포인터는 아무것도 가리키지 않는 포인터를 의미한다.
- 이는, 어떤 것이든 가리킬 수 있는 포인터, 참조할 대상체가 정해져 있지 않은 포인터이다.
- void 포인터 변수를 사용하여 값을 참조할 때는 **캐스트 연산자를 사용하여 포인터 자료형을 명시한 후** 참조해야 한다.
  - **즉, void형 포인터가 나오면, 포인터 형변환이 들어간다고 생각하면 된다**

### void 포인터의 사용처

런타임 중(실행 중) 주소 타입이 다양한 주소가 들어올 때(int형, char 형 등) 

```c
#include <stdio.h>

int main() {
	char ch = 'A';
	int num = 100;
	double dnum = 5.6;

	void *ptr; // void형 포인터 // void형 포인터를 매개변수로 설정하면, 타입에 구애받지 않는다 => fwrite, fread;

	printf("ptr: sizeof : %d \n", sizeof(ptr));

	ptr = &ch;

	printf("inside:  %c", *(char*)ptr); // char * 연산자를 사용하여 포인터 자료형(char *)을 명시

	return 0;
}
```

 

## 7. 함수 포인터







