# 동적 메모리 할당

메모리는 4개의 세그먼트로 이루어지는데, 각각의 특징은 다음과 같다.

1. 스택 세그먼트의 변수

- 함수 호출시 할당 / 함수 종료시 소멸

- 여기 선언된 배열은 고정 크기 배열



2. 데이터 세그먼트의 변수

- 프로그램 실행시 할당, 프로그램 종료시 소멸

- 즉, 프로그램의 처음부터 끝까지 남아있다.

- 여기 선언된 배열도 고정크기 배열이다.
- => 원칙적으로, 실행문이 오기 전에 선언문이 와야 하며, 이 규칙은 C99버전 이전에는 에러였다.



3. 그리고, 개발자가 직접 메모리 할당과 반납을 할 수 있는 힙 세그먼트이다.

- 예상보다 적은 크기의 데이터가 메모리에 들어가는 경우, 고정된 배열 크기만큼 할당받는 것은 낭비이므로, 동적 할당이 필요하다.



## 1. 힙 세그먼트

힙 세그먼트의 메모리 할당은 메모리 할당이 컴파일 타임이 아닌 런타임에서 이루어진다.

해당 세그먼트에는 **포인터 변수**를 통해서만 접근 가능하며, 헤더파일 <stdlib.h>에 선언된 함수들을 가지고 조작 및 접근 한다.

- 함수를 통해 메모리 할당 요청을 하고, 사용하지 않을 때는 반납할 수 있다.
- 메모리 사용하다 공간이 부족하거나 남을 때는 더 큰, 더 작은 크기로 재할당도 가능(원본 데이터 유지)

연결 리스트와 큐, 스택, 이진 트리 등 자료구조를 체계적이고 논리적으로 구현하는 알고리즘에서 일반적으로 사용되는 영역이다.

힙 세그먼트는 스택과 마찬가지로 재활용 영역이다. 즉, 처음 할당받으면 쓰레기 값이 있다.



### 참고: 객체지향 프로그래밍에서의 힙 세그먼트

객체지향 프로그래밍에서는, 객체는 힙 영역에, 객체 변수는 스택 영역에 만들어져서, 객체 변수를 사용할 때 힙 영역음 참조하게 됨;



## 2. 동적 할당 함수의 종류

총 4가지의 함수를 사용한다.

1. malloc
2. calloc
3. realloc
4. free

각 함수는 모두 void형 포인터를 반환하는 제너릭 함수이므로, 선언 및 정의할 때 포인터 형변환이 필수이다!

### 1. malloc()

- 함수 원형(size_t는 unsigned int를 뜻함)
  - `void *malloc(size_t size)`

- 예시
  - `ptr = (int *)malloc(100);`
- 설명
  - 인수로 크기(byte단위)를 넘겨주면 운영체제에서는 비어 있는 영역을 할당해 그 **시작 주소를 반환**
  - 만약 함수가 메모리를 할당받을 수 없는 상태라면 NULL 값을 반환

### 2. calloc()

- 함수 원형
  - `void *malloc(size_t num_elements, size_t element_size);`
- 예시
  - `ptr = (int *)calloc(10, sizeof(int));`
- 설명
  - **size_t num_elements * size_t element_size 만큼의 크기를 할당**하면서, **할당된 공간을 자동으로 0으로 초기화**
  - 사용 전 할당받은 메모리에 값을 저장하는 프로그램이라면 굳이 쓸 필요 없음

### 3. realloc()

- 함수 원형
  - `void *realloc(void *ptr, size_t size);`
- 예시
  - `ptr = (int *)calloc(ptr, 200);`
- 설명
  - 이미 할당되어 있는 영역을 다시 size만큼 재할당하며 새로운 영역의 시작 주소를 반환함
  - 만약 뒤쪽의 공간이 부족하다면, 새로운 넉넉한 공간을 찾아 할당한 뒤 기존 메모리의 내용 복사, 기존 메모리 반납
  - **즉, 메모리의 기존 데이터를 보장함**

### 4. free()

- 함수 원형
  - `void free(void *ptr);`
- 예시
  - `free(ptr);`
- 설명
  - free 함수의 인수는, 위의 세 함수의 호출에서 반환 받은 값, 즉 메모리 주소여아 함!
  - 이 함수는 할당 받은 영역을 해제하고, 이렇게 해제된 영역은 다른 동적 할당시 사용 가능
  - **할당된 공간 중 일부만 해제 불가능**

### 주의할 점

1. 힙 영역을 free()함수를 통해 해제하지 않으면, 프로세스가 끝나기 전까지 **할당된 상태로 남아있는다.**
   - 누군가가 해당 주소를 알고 있으면 사용이 가능하지만 만약 적절이 처리하지 않아 해당 주소를 잃어버리면, 해제가 힘들다.
     - **메모리 누수 발생**
2. 해제한 힙 영역의 주소를 free()로 다시 해제시도했을 경우, 프로세스가 죽어버린다.
   - 또한, 해제된 메모리에 함부로 접근했을 때는 오류가 발생할 수 있다.
3. 해제 후 할당되었던 포인터에 NULL포인터를 할당해서 오류를 방지하자
   - `ptr = NULL;`

```c
#include <stdlib.h>
#include <stdio.h>

int main() {
	
	// malloc 성공하면 시작주소, 실패하면 NULL 포인터 반환
	char *ptr;

	while (1) {
		ptr = (char *)malloc(100); // 포인터와 같은 타입으로 캐스팅

		if (ptr == NULL) {
			perror("Error ");
			exit(1);
		}

		printf("input string ?\n");
		gets(ptr);

		if (!strcmp(ptr, "end")) {
			break;
		}

		printf("ptr: %p, %s\n", ptr, ptr);
		free(ptr);	// 해제한 힙 영역은, 재할당 가능 => 해제하지 않으면 함수가 끝나도 free를 만나기 전까지 남아있음
					// 누군가가 해당 주소를 알고 있다면, 계속 사용 가능 
					// => 그런데, 적절히 처리하지 않아 주소를 잃어버리면, 힙에는 남아 있더라도 해제가 힘들어, 메모리 누수가 발생!
	}					

	free(ptr);	// 괄호 안의 => 힙 영역의 주소를 해제 => ptr 자체는 함수가 끝낼때 해제
	ptr = NULL; // 안전하게, 해제한 주소를 처리
	// free(ptr);						// => 해제된 메모리를 적절하게 처리하지 않고 다시 해제하면 죽음
	// printf("ptr: %p, %s", ptr, ptr); // => 해제된 메모리에는 접근하면 안된다!
	
	
	return 0;
}
```

